using Google.Authenticator;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Formatting;
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;
using vm.data.library.blockchain.api.device.Model;
using vm.data.library.blockchain.api.device.Response;
using vm.data.library.blockchain.secureidentity.api;

namespace Payment_Client
{
    /// <summary>
    /// This Device, initial registration or re-registration
    /// </summary>
    public class Register
    {
        /// <summary>
        /// Register Device with Block Chain Register
        /// </summary>
        public static string RegisterDevice(string name, string institutionSin, string entity_sin, string token)
        {
            //Properties.Settings.Default.SECUREIDENTIES = string.Empty;
            String BLOCKCHAINREG_PLUGIN_INFO = "Block Chain Payment C# Library " + Settings.Default.BLOCKCHAINREG_API_VERSION + " on " + System.Environment.MachineName;
            // Get Registration host end point
            string BLOCKCHAINREG_URL = Helper.GetHostUrl(name);

            DeviceSecureIdentities ids = new(Settings.Default.SECUREIDENTIES);
            DeviceSecureIdentity id = ids.getLastByLable(name, SinNodeType.Payment);
            string sin;
            if (id == null)
            {
                // Generate Device keys
                sin = Device.GenECDSAKeys(name, entity_sin, institutionSin); // Signature Key
                Device.GenECDHKeys(name, entity_sin, institutionSin);        // Exchange Key
            }
            else
                sin = id.sin;

            // Register Secure Identity
            string code;
            if (!String.IsNullOrEmpty(token) && Helper.IsNumeric(token))
            {
                // Code generated by external HOTP device
                code = token;
            }
            else
            {
                // Generate from shared onetime secret
                byte[] accountCodebytes = Encoding.UTF8.GetBytes(token);
                string encodedSecretKey = Helper.Base32Encoding.ToString(accountCodebytes);
                // Generate Key
                var tfa = new TwoFactorAuthenticator();
                code = tfa.GetCurrentPIN(encodedSecretKey);
            }

            DeviceSecureIdentity record = new()
            {
                entity_sin = entity_sin,
                host_sin = institutionSin,
                host_type = SinNodeType.Payment,
                sin = sin,
                token = code, //HOTP code
                ecdsa_PublicKeyBlob = id.ecdsa_PublicKeyBlob,
                ecdh_PublicKeyBlob = id.ecdh_PublicKeyBlob
            };

            HttpClient _httpClient = new();
            string uri = BLOCKCHAINREG_URL + "SecureIdentity/Register";
            _httpClient.BaseAddress = new Uri(uri);
            _httpClient.DefaultRequestHeaders.Clear();
            _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

            _httpClient.DefaultRequestHeaders.Add("x-accept-version", Settings.Default.BLOCKCHAINREG_API_VERSION);
            _httpClient.DefaultRequestHeaders.Add("x-blockchain-plugin-info", BLOCKCHAINREG_PLUGIN_INFO);
            _httpClient.DefaultRequestHeaders.Add("x-identity", sin); // Device Secure Identity
            // Prove this device is linked to this SIN, and the device holds the private key
            byte[] signature = Device.SignData(name, Encoding.UTF8.GetBytes(entity_sin));
            _httpClient.DefaultRequestHeaders.Add("x-signature", Convert.ToBase64String(signature));
            if (!String.IsNullOrEmpty(token))
                _httpClient.DefaultRequestHeaders.Add("x-token", token); // Shared HOTP secret??

            // Post request
            HttpResponseMessage response = _httpClient.PostAsJsonAsync(uri, record).Result;
            // Check for error
            if (!response.IsSuccessStatusCode)
            {

                return String.Empty;
            }

            // Registration will return, node ECDH Public Key, used in mutual Auth and Key Management protocols
            byte[] content = response.Content.ReadAsByteArrayAsync().Result;
#if DEBUG
            string sjson = System.Text.Encoding.ASCII.GetString(content);
#endif
            // Decode JSON 
            JsonMediaTypeFormatter mf = new();
            MemoryStream ms = new(content);
            Task<object> d = mf.ReadFromStreamAsync(typeof(SecureIdentityRegistrationResponse), ms, null, null);
            SecureIdentityRegistrationResponse deviceData = (SecureIdentityRegistrationResponse)d.Result;
            // Save Host ECDH Public Key to device Identity

            // Update
            //ids.identities.Remove(id);
            id.host_sin_ecdh_PublicKeyBlob = deviceData.HostECDHPublicKey; // Add Key
            id.token = deviceData.JWTToken; // Add JWT Token
            id.host_type = record.host_type; // reflect binding
            //ids.identities.Add(id);

            Settings.Default.SECUREIDENTIES = ids.asJason();
            Settings.Default.Save();
            // Return Base32 Shared secret, must be bound to Device SecureIdentity
            return deviceData.RecoveryToken;
        }

    }
}
